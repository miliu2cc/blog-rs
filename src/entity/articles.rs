//! `SeaORM` Entity, @generated by sea-orm-codegen 1.0.1



use sea_orm :: entity :: prelude :: * ; use serde :: { Deserialize , Serialize } ;

# [derive (Clone , Debug , PartialEq , DeriveEntityModel , Eq , Serialize , Deserialize)] # [sea_orm (table_name = "articles")] pub struct Model { # [sea_orm (primary_key)] pub id : i32 , pub title : String , pub cover_url : Option < String > , # [sea_orm (column_type = "Text")] pub content : String , pub user_id : i32 , pub created_at : Option < DateTimeUtc > , pub updated_at : Option < DateTimeUtc > , pub is_top : Option < i8 > , pub is_published : Option < i8 > , pub is_deleted : Option < i8 > , pub category_id : Option < i32 > , }

# [derive (Copy , Clone , Debug , EnumIter , DeriveRelation)] pub enum Relation { # [sea_orm (has_many = "super::article_tags::Entity")] ArticleTags , # [sea_orm (belongs_to = "super::categories::Entity" , from = "Column::CategoryId" , to = "super::categories::Column::Id" , on_update = "Restrict" , on_delete = "SetNull" ,)] Categories , # [sea_orm (belongs_to = "super::users::Entity" , from = "Column::UserId" , to = "super::users::Column::Id" , on_update = "Restrict" , on_delete = "Cascade" ,)] Users , }

impl Related < super :: article_tags :: Entity > for Entity { fn to () -> RelationDef { Relation :: ArticleTags . def () } }

impl Related < super :: categories :: Entity > for Entity { fn to () -> RelationDef { Relation :: Categories . def () } }

impl Related < super :: users :: Entity > for Entity { fn to () -> RelationDef { Relation :: Users . def () } }

impl Related < super :: tags :: Entity > for Entity { fn to () -> RelationDef { super :: article_tags :: Relation :: Tags . def () } fn via () -> Option < RelationDef > { Some (super :: article_tags :: Relation :: Articles . def () . rev ()) } }

impl ActiveModelBehavior for ActiveModel { }